{% extends "patient/base.html" %}
{% load static i18n %}

{% block content %}
    <h1 class="title">
        drf-chunked-upload
    </h1>

    <div>
        <input type="text" id="username" placeholder="Username" value="admin">
        <input type="password" id="password" placeholder="Password" value="admin">
        <button id="loginButton">Login</button>
    </div>
    <div id="token-status"></div>
    <hr>

    <h3 class="title">
        Upload Scan
    </h3>
    <div>
        <label for="scanIdInput">Scan ID to associate with:</label>
        <input type="number" id="scanIdInput" value="1">
    </div>
    <br>
    <input type="file" id="fileInput">
    <button id="uploadButton">Upload</button>
    <div id="progress"></div>
{% endblock %}


{% block javascript %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>

    <script type="text/javascript">
        const fileInput = document.getElementById('fileInput');
        const uploadButton = document.getElementById('uploadButton');
        const progressDiv = document.getElementById('progress');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginButton = document.getElementById('loginButton');
        const tokenDiv = document.getElementById('token-status');
        const scanIdInput = document.getElementById('scanIdInput');

        const CHUNK_SIZE = 1024 * 1024 * 5; // 1MB
        const UPLOAD_URL = '/api/patient/scans/upload/';
        const TOKEN_URL = '/api/token/';

        let accessToken = null;

        loginButton.addEventListener('click', async () => {
            const username = usernameInput.value;
            const password = passwordInput.value;
            tokenDiv.innerText = 'Logging in...';
            try {
                const response = await fetch(TOKEN_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(JSON.stringify(errorData));
                }

                const data = await response.json();
                accessToken = data.access;
                tokenDiv.innerText = 'Logged in successfully!';
                tokenDiv.style.color = 'green';
            } catch (error) {
                tokenDiv.innerText = `Login failed: ${error.message}`;
                tokenDiv.style.color = 'red';
                console.error('Login failed:', error);
            }
        });

        const calculateMD5 = (file, callback) => {
            const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
            const chunks = Math.ceil(file.size / CHUNK_SIZE);
            let currentChunk = 0;
            const spark = new SparkMD5.ArrayBuffer();
            const fileReader = new FileReader();

            fileReader.onload = (e) => {
                spark.append(e.target.result);
                currentChunk++;
                progressDiv.innerText = `Calculating MD5: ${Math.round((currentChunk/chunks)*100)}%`;
                if (currentChunk < chunks) {
                    loadNextChunk();
                } else {
                    callback(spark.end());
                }
            };
            fileReader.onerror = () => {
                console.error('MD5 calculation failed');
                progressDiv.innerText = 'Error calculating MD5.';
                progressDiv.style.color = 'red';
            };
            const loadNextChunk = () => {
                const start = currentChunk * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));
            };
            loadNextChunk();
        };

        uploadButton.addEventListener('click', () => {
            if (!accessToken) {
                progressDiv.innerText = 'Please log in first.';
                progressDiv.style.color = 'orange';
                return;
            }
            const file = fileInput.files[0];
            if (!file) {
                progressDiv.innerText = 'Please select a file.';
                progressDiv.style.color = 'orange';
                return;
            }

            progressDiv.innerText = 'Calculating MD5 checksum...';
            progressDiv.style.color = 'black';

            calculateMD5(file, (md5) => {
                progressDiv.innerText = `MD5: ${md5}. Starting upload...`;
                startUpload(file, md5);
            });
        });

        async function startUpload(file, md5) {
            const scanId = scanIdInput.value;
            if (!scanId) {
                progressDiv.innerText = 'Scan ID is required.';
                return;
            }

            const totalSize = file.size;
            let start = 0;
            let uploadUrl = UPLOAD_URL; // First request goes to the base URL
            let isFirstChunk = true;

            try {
                while (start < totalSize) {
                    const end = Math.min(start + CHUNK_SIZE, totalSize);
                    const chunk = file.slice(start, end);
                    const contentRange = `bytes ${start}-${end - 1}/${totalSize}`;

                    progressDiv.innerText = `Uploading chunk... ${Math.round((end/totalSize)*100)}%`;

                    const formData = new FormData();
                    formData.append('file', chunk);
                    formData.append('filename', file.name);

                    // Add scan ID only to the first chunk's request
                    if (isFirstChunk) {
                        formData.append('scan', scanId);
                    }

                    const chunkResponse = await fetch(uploadUrl, {
                        method: 'PUT',
                        headers: {
                            'Content-Range': contentRange,
                            'Authorization': `Bearer ${accessToken}`,
                        },
                        body: formData,
                    });

                    if (!chunkResponse.ok) {
                        const errorData = await chunkResponse.json();
                        throw new Error(`Chunk upload failed: ${JSON.stringify(errorData)}`);
                    }

                    const responseData = await chunkResponse.json();
                    uploadUrl = responseData.url; // Use the new URL for subsequent chunks
                    isFirstChunk = false;
                    start = end;
                }

                // Finalize upload
                progressDiv.innerText = 'Finalizing upload...';
                const finalResponse = await fetch(uploadUrl, { // Use the last received URL
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`,
                    },
                    body: JSON.stringify({ md5: md5 }),
                });

                if (!finalResponse.ok) {
                    const errorData = await finalResponse.json();
                    throw new Error(`Finalization failed: ${JSON.stringify(errorData)}`);
                }
                
                const finalData = await finalResponse.json();
                progressDiv.innerText = 'Upload complete!';
                progressDiv.style.color = 'green';
                console.log('Final response:', finalData);

            } catch (error) {
                progressDiv.innerText = `Error: ${error.message}`;
                progressDiv.style.color = 'red';
                console.error('Upload failed:', error);
            }
        }
    </script>
{% endblock %}